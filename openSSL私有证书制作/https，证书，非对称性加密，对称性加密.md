---
title: https，证书，非对称性加密，对称性加密
updated: 2023-09-08 07:12:32Z
created: 2023-09-08 03:26:56Z
latitude: 34.34157500
longitude: 108.93977000
altitude: 0.0000
---

# https，证书，非对称性加密，对称性加密

0. 一个服务的网站会先根据一套算法生成public key 和 private key 
> public key 通常用来加密， private用来解密； 也可以反过来，private加密，public解密

1. 用户通过浏览器向服务单发请求；这个过程会一并将客户端支持的加密算法，sessionID，路径等信息传递给服务端。
2. 服务端收到信息后，选择一组加密算法（用来hash信息的），结合一些信息（下面所列）包装成一个证书，发给客户端。
> 证书包含： 
> 公钥 public key
> 持有者信息
> 证书认证机构CA的信息
> CA对这份文件的数字签名及使用方法
> 证书有效期
> 其他额外信息

证书就是告诉客户端，这个服务商是合法的， 不是冒充的。 因为这个网站经过认证的，证书上面有CA的签名。

---

> 证书的生成过程（制作过程，包括自签名证书）

> > CA机构的证书也就是根证书一定是自签名的证书
1）CA机构首先把【持有者的公钥publick key（注意这里不是CA的public key）】、用途、颁发者、有效期等信息打成一个包，然后对这个包进行hash计算，得到一个值
2）然后，CA使用自己的私钥对hash进行加密，生成 签名。
3） 最后把签名添加到证书上，形成数字证书


3. 客户端收到证书后，先验证证书的合法性(有效期，发证机构/证书链，网址信息是否一致等)然后取出public key， 然后基于选择的算法生成一个session key， 再用public key加密session key 传递给服务端。

> 客户端校验证书
>  1. 验证证书有效期
>  2. 根据【证书链】验证证书是否合法，是否被篡改
>  3. 验证签名
---
>  验证签名：
>  签名是一个hash值，  客户端根据服务端同样的算法，把“公钥、用途、颁发者、有效期等信息打成一个包” 打成一个包，计算得到一个hash值； 叫做hash1
>  签名经过了CA private key加密，需要用CA的public key解密， 通常浏览器或者操作系统都内置了CA机构的public key，于是浏览找到这个CA的public key解密签名，得到hash2
>  比较 hash1 和 hash2

> 证书链：
> 有些网站的证书是二级或者三级证书， 这些证书通常是由中间证书签发的
> （类似于，骑士的认证， 第一个骑士一定是皇帝认证的， 接下来的骑士可以认证骑士）
> 我们需要根据证书里面的信息先找到CA根机构证书，根证书验证下一级证书的真伪， 然后一层层找到当前证书， 只有上一层证书能证明下一级证书的合法性。
> 只有证明中间签发证书的证书是有效的合法的，才能保证这些中间证书签发的证书是有效的合法
> 根证书通常内置在计算机系统内或者浏览器的存储路径中
>


5. 服务端收到session key后，用private key解密，拿到session key
6. 然后开始正常的C-S 数据通信，通过session key来认证